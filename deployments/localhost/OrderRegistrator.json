{
  "address": "0xDB4d5148954BdbfDA61B15f4c11904284A933bD4",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IOrderMixin",
          "name": "limitOrderProtocol",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "BadSignature",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "receiver",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "makerAsset",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "takerAsset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "makingAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takingAmount",
              "type": "uint256"
            },
            {
              "internalType": "MakerTraits",
              "name": "makerTraits",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct IOrderMixin.Order",
          "name": "order",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "extension",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "OrderRegistered",
      "type": "event"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "receiver",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "makerAsset",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "takerAsset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "makingAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takingAmount",
              "type": "uint256"
            },
            {
              "internalType": "MakerTraits",
              "name": "makerTraits",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOrderMixin.Order",
          "name": "order",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "extension",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "registerOrder",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x2c38ab85ba455ffe8731b3b2a2f8e873cc161d982513559361783d441b4d84d2",
  "receipt": {
    "to": null,
    "from": "0xAA74E80De15758Fe983Cb6102176ef2cE195ECfE",
    "contractAddress": "0xDB4d5148954BdbfDA61B15f4c11904284A933bD4",
    "transactionIndex": 0,
    "gasUsed": "430121",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x822f74b1391976abd4dd93e46253d606fec55996fa16a346888bd0e15480600d",
    "transactionHash": "0x2c38ab85ba455ffe8731b3b2a2f8e873cc161d982513559361783d441b4d84d2",
    "logs": [],
    "blockNumber": 23468910,
    "cumulativeGasUsed": "430121",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x111111125421ca6dc452d289314280a0f8842a65"
  ],
  "numDeployments": 1,
  "solcInputHash": "adaa8fa8b37a12f49a6ac91238cddda9",
  "metadata": "{\"compiler\":{\"version\":\"0.8.30+commit.73712a01\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IOrderMixin\",\"name\":\"limitOrderProtocol\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadSignature\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"receiver\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"makerAsset\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"takerAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"MakerTraits\",\"name\":\"makerTraits\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IOrderMixin.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extension\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"OrderRegistered\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"receiver\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"makerAsset\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"takerAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"MakerTraits\",\"name\":\"makerTraits\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderMixin.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"extension\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"registerOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"OrderRegistered((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes)\":{\"params\":{\"extension\":\"The extension data associated with the order.\",\"order\":\"The order that was registered.\",\"signature\":\"The signature of the order.\"}}},\"kind\":\"dev\",\"methods\":{},\"title\":\"OrderRegistrator\",\"version\":1},\"userdoc\":{\"events\":{\"OrderRegistered((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes)\":{\"notice\":\"Emitted when an order is registered.\"}},\"kind\":\"user\",\"methods\":{\"registerOrder((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes)\":{\"notice\":\"See {IOrderRegistrator-registerOrder}.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/helpers/OrderRegistrator.sol\":\"OrderRegistrator\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype Address is uint256;\\n\\n/**\\n* @notice AddressLib\\n* @notice Library for working with addresses encoded as uint256 values, which can include flags in the highest bits.\\n*/\\nlibrary AddressLib {\\n    uint256 private constant _LOW_160_BIT_MASK = (1 << 160) - 1;\\n\\n    /**\\n    * @notice Returns the address representation of a uint256.\\n    * @param a The uint256 value to convert to an address.\\n    * @return The address representation of the provided uint256 value.\\n    */\\n    function get(Address a) internal pure returns (address) {\\n        return address(uint160(Address.unwrap(a) & _LOW_160_BIT_MASK));\\n    }\\n\\n    /**\\n    * @notice Checks if a given flag is set for the provided address.\\n    * @param a The address to check for the flag.\\n    * @param flag The flag to check for in the provided address.\\n    * @return True if the provided flag is set in the address, false otherwise.\\n    */\\n    function getFlag(Address a, uint256 flag) internal pure returns (bool) {\\n        return (Address.unwrap(a) & flag) != 0;\\n    }\\n\\n    /**\\n    * @notice Returns a uint32 value stored at a specific bit offset in the provided address.\\n    * @param a The address containing the uint32 value.\\n    * @param offset The bit offset at which the uint32 value is stored.\\n    * @return The uint32 value stored in the address at the specified bit offset.\\n    */\\n    function getUint32(Address a, uint256 offset) internal pure returns (uint32) {\\n        return uint32(Address.unwrap(a) >> offset);\\n    }\\n\\n    /**\\n    * @notice Returns a uint64 value stored at a specific bit offset in the provided address.\\n    * @param a The address containing the uint64 value.\\n    * @param offset The bit offset at which the uint64 value is stored.\\n    * @return The uint64 value stored in the address at the specified bit offset.\\n    */\\n    function getUint64(Address a, uint256 offset) internal pure returns (uint64) {\\n        return uint64(Address.unwrap(a) >> offset);\\n    }\\n}\\n\",\"keccak256\":\"0xe860b410ed5371b9732daab80982eef0a42ae48474716a89725ca744e27b7d75\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @title ECDSA signature operations\\n * @notice Provides functions for recovering addresses from signatures and verifying signatures, including support for EIP-2098 compact signatures.\\n */\\nlibrary ECDSA {\\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n    // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n    //\\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n    // these malleable signatures as well.\\n    uint256 private constant _S_BOUNDARY = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0 + 1;\\n    uint256 private constant _COMPACT_S_MASK = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n    uint256 private constant _COMPACT_V_SHIFT = 255;\\n\\n    /**\\n     * @notice Recovers the signer's address from the signature.\\n     * @dev Recovers the address that has signed a hash with `(v, r, s)` signature.\\n     * @param hash The keccak256 hash of the data signed.\\n     * @param v The recovery byte of the signature.\\n     * @param r The first 32 bytes of the signature.\\n     * @param s The second 32 bytes of the signature.\\n     * @return signer The address of the signer.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (address signer) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            if lt(s, _S_BOUNDARY) {\\n                let ptr := mload(0x40)\\n\\n                mstore(ptr, hash)\\n                mstore(add(ptr, 0x20), v)\\n                mstore(add(ptr, 0x40), r)\\n                mstore(add(ptr, 0x60), s)\\n                mstore(0, 0)\\n                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\\n                signer := mload(0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Recovers the signer's address from the signature using `r` and `vs` components.\\n     * @dev Recovers the address that has signed a hash with `r` and `vs`, where `vs` combines `v` and `s`.\\n     * @param hash The keccak256 hash of the data signed.\\n     * @param r The first 32 bytes of the signature.\\n     * @param vs The combined `v` and `s` values of the signature.\\n     * @return signer The address of the signer.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal view returns (address signer) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let s := and(vs, _COMPACT_S_MASK)\\n            if lt(s, _S_BOUNDARY) {\\n                let ptr := mload(0x40)\\n\\n                mstore(ptr, hash)\\n                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))\\n                mstore(add(ptr, 0x40), r)\\n                mstore(add(ptr, 0x60), s)\\n                mstore(0, 0)\\n                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\\n                signer := mload(0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Recovers the signer's address from a hash and a signature.\\n     * @param hash The keccak256 hash of the signed data.\\n     * @param signature The full signature from which the signer will be recovered.\\n     * @return signer The address of the signer.\\n     */\\n    /// @dev WARNING!!!\\n    /// There is a known signature malleability issue with two representations of signatures!\\n    /// Even though this function is able to verify both standard 65-byte and compact 64-byte EIP-2098 signatures\\n    /// one should never use raw signatures for any kind of invalidation logic in their code.\\n    /// As the standard and compact representations are interchangeable any invalidation logic that relies on\\n    /// signature uniqueness will get rekt.\\n    /// More info: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h\\n    function recover(bytes32 hash, bytes calldata signature) internal view returns (address signer) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            // memory[ptr:ptr+0x80] = (hash, v, r, s)\\n            switch signature.length\\n            case 65 {\\n                // memory[ptr+0x20:ptr+0x80] = (v, r, s)\\n                mstore(add(ptr, 0x20), byte(0, calldataload(add(signature.offset, 0x40))))\\n                calldatacopy(add(ptr, 0x40), signature.offset, 0x40)\\n            }\\n            case 64 {\\n                // memory[ptr+0x20:ptr+0x80] = (v, r, s)\\n                let vs := calldataload(add(signature.offset, 0x20))\\n                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))\\n                calldatacopy(add(ptr, 0x40), signature.offset, 0x20)\\n                mstore(add(ptr, 0x60), and(vs, _COMPACT_S_MASK))\\n            }\\n            default {\\n                ptr := 0\\n            }\\n\\n            if ptr {\\n                if lt(mload(add(ptr, 0x60)), _S_BOUNDARY) {\\n                    // memory[ptr:ptr+0x20] = (hash)\\n                    mstore(ptr, hash)\\n\\n                    mstore(0, 0)\\n                    pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\\n                    signer := mload(0)\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Verifies the signature for a hash, either by recovering the signer or using EIP-1271's `isValidSignature` function.\\n     * @dev Attempts to recover the signer's address from the signature; if the address is non-zero, checks if it's valid according to EIP-1271.\\n     * @param signer The address to validate the signature against.\\n     * @param hash The hash of the signed data.\\n     * @param signature The signature to verify.\\n     * @return success True if the signature is verified, false otherwise.\\n     */\\n    function recoverOrIsValidSignature(\\n        address signer,\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) internal view returns (bool success) {\\n        if (signer == address(0)) return false;\\n        if ((signature.length == 64 || signature.length == 65) && recover(hash, signature) == signer) {\\n            return true;\\n        }\\n        return isValidSignature(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @notice Verifies the signature for a hash, either by recovering the signer or using EIP-1271's `isValidSignature` function.\\n     * @dev Attempts to recover the signer's address from the signature; if the address is non-zero, checks if it's valid according to EIP-1271.\\n     * @param signer The address to validate the signature against.\\n     * @param hash The hash of the signed data.\\n     * @param v The recovery byte of the signature.\\n     * @param r The first 32 bytes of the signature.\\n     * @param s The second 32 bytes of the signature.\\n     * @return success True if the signature is verified, false otherwise.\\n     */\\n    function recoverOrIsValidSignature(\\n        address signer,\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (bool success) {\\n        if (signer == address(0)) return false;\\n        if (recover(hash, v, r, s) == signer) {\\n            return true;\\n        }\\n        return isValidSignature(signer, hash, v, r, s);\\n    }\\n\\n    /**\\n     * @notice Verifies the signature for a hash, either by recovering the signer or using EIP-1271's `isValidSignature` function.\\n     * @dev Attempts to recover the signer's address from the signature; if the address is non-zero, checks if it's valid according to EIP-1271.\\n     * @param signer The address to validate the signature against.\\n     * @param hash The hash of the signed data.\\n     * @param r The first 32 bytes of the signature.\\n     * @param vs The combined `v` and `s` values of the signature.\\n     * @return success True if the signature is verified, false otherwise.\\n     */\\n    function recoverOrIsValidSignature(\\n        address signer,\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal view returns (bool success) {\\n        if (signer == address(0)) return false;\\n        if (recover(hash, r, vs) == signer) {\\n            return true;\\n        }\\n        return isValidSignature(signer, hash, r, vs);\\n    }\\n\\n    /**\\n     * @notice Verifies the signature for a given hash, attempting to recover the signer's address or validates it using EIP-1271 for 65-byte signatures.\\n     * @dev Attempts to recover the signer's address from the signature. If the address is a contract, checks if the signature is valid according to EIP-1271.\\n     * @param signer The expected signer's address.\\n     * @param hash The keccak256 hash of the signed data.\\n     * @param r The first 32 bytes of the signature.\\n     * @param vs The last 32 bytes of the signature, with the last byte being the recovery id.\\n     * @return success True if the signature is valid, false otherwise.\\n     */\\n    function recoverOrIsValidSignature65(\\n        address signer,\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal view returns (bool success) {\\n        if (signer == address(0)) return false;\\n        if (recover(hash, r, vs) == signer) {\\n            return true;\\n        }\\n        return isValidSignature65(signer, hash, r, vs);\\n    }\\n\\n    /**\\n     * @notice Validates a signature for a hash using EIP-1271, if `signer` is a contract.\\n     * @dev Makes a static call to `signer` with `isValidSignature` function selector from EIP-1271.\\n     * @param signer The address of the signer to validate against, which could be an EOA or a contract.\\n     * @param hash The hash of the signed data.\\n     * @param signature The signature to validate.\\n     * @return success True if the signature is valid according to EIP-1271, false otherwise.\\n     */\\n    function isValidSignature(\\n        address signer,\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) internal view returns (bool success) {\\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature));\\n        // return success && data.length == 32 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\\n        bytes4 selector = IERC1271.isValidSignature.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            mstore(ptr, selector)\\n            mstore(add(ptr, 0x04), hash)\\n            mstore(add(ptr, 0x24), 0x40)\\n            mstore(add(ptr, 0x44), signature.length)\\n            calldatacopy(add(ptr, 0x64), signature.offset, signature.length)\\n            if staticcall(gas(), signer, ptr, add(0x64, signature.length), 0, 0x20) {\\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Validates a signature for a hash using EIP-1271, if `signer` is a contract.\\n     * @dev Makes a static call to `signer` with `isValidSignature` function selector from EIP-1271.\\n     * @param signer The address of the signer to validate against, which could be an EOA or a contract.\\n     * @param hash The hash of the signed data.\\n     * @param v The recovery byte of the signature.\\n     * @param r The first 32 bytes of the signature.\\n     * @param s The second 32 bytes of the signature.\\n     * @return success True if the signature is valid according to EIP-1271, false otherwise.\\n     */\\n    function isValidSignature(\\n        address signer,\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (bool success) {\\n        bytes4 selector = IERC1271.isValidSignature.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            mstore(ptr, selector)\\n            mstore(add(ptr, 0x04), hash)\\n            mstore(add(ptr, 0x24), 0x40)\\n            mstore(add(ptr, 0x44), 65)\\n            mstore(add(ptr, 0x64), r)\\n            mstore(add(ptr, 0x84), s)\\n            mstore8(add(ptr, 0xa4), v)\\n            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {\\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Validates a signature for a hash using EIP-1271, if `signer` is a contract.\\n     * @dev Makes a static call to `signer` with `isValidSignature` function selector from EIP-1271.\\n     * @param signer The address of the signer to validate against, which could be an EOA or a contract.\\n     * @param hash The hash of the signed data.\\n     * @param r The first 32 bytes of the signature.\\n     * @param vs The last 32 bytes of the signature, with the last byte being the recovery id.\\n     * @return success True if the signature is valid according to EIP-1271, false otherwise.\\n     */\\n    function isValidSignature(\\n        address signer,\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal view returns (bool success) {\\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs)));\\n        // return success && data.length == 32 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\\n        bytes4 selector = IERC1271.isValidSignature.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            mstore(ptr, selector)\\n            mstore(add(ptr, 0x04), hash)\\n            mstore(add(ptr, 0x24), 0x40)\\n            mstore(add(ptr, 0x44), 64)\\n            mstore(add(ptr, 0x64), r)\\n            mstore(add(ptr, 0x84), vs)\\n            if staticcall(gas(), signer, ptr, 0xa4, 0, 0x20) {\\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Verifies if a 65-byte signature is valid for a given hash, according to EIP-1271.\\n     * @param signer The address of the signer to validate against, which could be an EOA or a contract.\\n     * @param hash The hash of the signed data.\\n     * @param r The first 32 bytes of the signature.\\n     * @param vs The combined `v` (recovery id) and `s` component of the signature, packed into the last 32 bytes.\\n     * @return success True if the signature is valid according to EIP-1271, false otherwise.\\n     */\\n    function isValidSignature65(\\n        address signer,\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal view returns (bool success) {\\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs & ~uint256(1 << 255), uint8(vs >> 255))));\\n        // return success && data.length == 32 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\\n        bytes4 selector = IERC1271.isValidSignature.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            mstore(ptr, selector)\\n            mstore(add(ptr, 0x04), hash)\\n            mstore(add(ptr, 0x24), 0x40)\\n            mstore(add(ptr, 0x44), 65)\\n            mstore(add(ptr, 0x64), r)\\n            mstore(add(ptr, 0x84), and(vs, _COMPACT_S_MASK))\\n            mstore8(add(ptr, 0xa4), add(27, shr(_COMPACT_V_SHIFT, vs)))\\n            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {\\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Generates a hash compatible with Ethereum's signed message format.\\n     * @dev Prepends the hash with Ethereum's message prefix before hashing it.\\n     * @param hash The hash of the data to sign.\\n     * @return res The Ethereum signed message hash.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 res) {\\n        // 32 is the length in bytes of hash, enforced by the type signature above\\n        // return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            mstore(0, 0x19457468657265756d205369676e6564204d6573736167653a0a333200000000) // \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\"\\n            mstore(28, hash)\\n            res := keccak256(0, 60)\\n        }\\n    }\\n\\n    /**\\n     * @notice Generates an EIP-712 compliant hash.\\n     * @dev Encodes the domain separator and the struct hash according to EIP-712.\\n     * @param domainSeparator The EIP-712 domain separator.\\n     * @param structHash The EIP-712 struct hash.\\n     * @return res The EIP-712 compliant hash.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 res) {\\n        // return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x1901000000000000000000000000000000000000000000000000000000000000) // \\\"\\\\x19\\\\x01\\\"\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            res := keccak256(ptr, 66)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x501b8b300cf98af055d4bb26eb936ec8cb8aac7cde5caae9c2d045a43d15c5e5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x4aaaf1c0737dd16e81f0d2b9833c549747a5ede6873bf1444bc72aa572d03e98\",\"license\":\"MIT\"},\"contracts/OrderLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.30;\\n\\nimport \\\"@1inch/solidity-utils/contracts/libraries/ECDSA.sol\\\";\\nimport \\\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\\\";\\n\\nimport \\\"./interfaces/IOrderMixin.sol\\\";\\nimport \\\"./libraries/MakerTraitsLib.sol\\\";\\nimport \\\"./libraries/ExtensionLib.sol\\\";\\nimport \\\"./libraries/AmountCalculatorLib.sol\\\";\\nimport \\\"./interfaces/IAmountGetter.sol\\\";\\n\\n/**\\n * @title OrderLib\\n * @dev The library provides common functionality for processing and manipulating limit orders.\\n * It provides functionality to calculate and verify order hashes, calculate trade amounts, and validate\\n * extension data associated with orders. The library also contains helper methods to get the receiver of\\n * an order and call getter functions.\\n */\\n library OrderLib {\\n    using AddressLib for Address;\\n    using MakerTraitsLib for MakerTraits;\\n    using ExtensionLib for bytes;\\n\\n    /// @dev Error to be thrown when the extension data of an order is missing.\\n    error MissingOrderExtension();\\n    /// @dev Error to be thrown when the order has an unexpected extension.\\n    error UnexpectedOrderExtension();\\n    /// @dev Error to be thrown when the order extension hash is invalid.\\n    error InvalidExtensionHash();\\n\\n    /// @dev The typehash of the order struct.\\n    bytes32 constant internal _LIMIT_ORDER_TYPEHASH = keccak256(\\n        \\\"Order(\\\"\\n            \\\"uint256 salt,\\\"\\n            \\\"address maker,\\\"\\n            \\\"address receiver,\\\"\\n            \\\"address makerAsset,\\\"\\n            \\\"address takerAsset,\\\"\\n            \\\"uint256 makingAmount,\\\"\\n            \\\"uint256 takingAmount,\\\"\\n            \\\"uint256 makerTraits\\\"\\n        \\\")\\\"\\n    );\\n    uint256 constant internal _ORDER_STRUCT_SIZE = 0x100;\\n    uint256 constant internal _DATA_HASH_SIZE = 0x120;\\n\\n    /**\\n      * @notice Calculates the hash of an order.\\n      * @param order The order to be hashed.\\n      * @param domainSeparator The domain separator to be used for the EIP-712 hashing.\\n      * @return result The EIP-712 hash of the order data.\\n      */\\n    function hash(IOrderMixin.Order calldata order, bytes32 domainSeparator) internal pure returns(bytes32 result) {\\n        bytes32 typehash = _LIMIT_ORDER_TYPEHASH;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            // keccak256(abi.encode(_LIMIT_ORDER_TYPEHASH, order));\\n            mstore(ptr, typehash)\\n            calldatacopy(add(ptr, 0x20), order, _ORDER_STRUCT_SIZE)\\n            result := keccak256(ptr, _DATA_HASH_SIZE)\\n        }\\n        result = ECDSA.toTypedDataHash(domainSeparator, result);\\n    }\\n\\n    /**\\n      * @notice Calculates the hash of an order in memory.\\n      * @param order The order to be hashed.\\n      * @param domainSeparator The domain separator to be used for the EIP-712 hashing.\\n      * @return result The EIP-712 hash of the order data.\\n      */\\n    function hashMemory(IOrderMixin.Order memory order, bytes32 domainSeparator) internal pure returns(bytes32 result) {\\n        bytes32 typehash = OrderLib._LIMIT_ORDER_TYPEHASH;\\n        uint256 dataHashSize = OrderLib._DATA_HASH_SIZE;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := sub(order, 0x20)\\n            let backup := mload(ptr)\\n            mstore(ptr, typehash)\\n\\n            // keccak256(abi.encode(OrderLib._LIMIT_ORDER_TYPEHASH, order))\\n            result := keccak256(ptr, dataHashSize)\\n\\n            mstore(ptr, backup)\\n        }\\n        result = ECDSA.toTypedDataHash(domainSeparator, result);\\n    }\\n\\n    /**\\n      * @notice Returns the receiver address for an order.\\n      * @param order The order.\\n      * @return receiver The address of the receiver, either explicitly defined in the order or the maker's address if not specified.\\n      */\\n    function getReceiver(IOrderMixin.Order calldata order) internal pure returns(address /*receiver*/) {\\n        address receiver = order.receiver.get();\\n        return receiver != address(0) ? receiver : order.maker.get();\\n    }\\n\\n    /**\\n      * @notice Calculates the making amount based on the requested taking amount.\\n      * @dev If getter is specified in the extension data, the getter is called to calculate the making amount,\\n      * otherwise the making amount is calculated linearly.\\n      * @param order The order.\\n      * @param extension The extension data associated with the order.\\n      * @param requestedTakingAmount The amount the taker wants to take.\\n      * @param remainingMakingAmount The remaining amount of the asset left to fill.\\n      * @param orderHash The hash of the order.\\n      * @return makingAmount The amount of the asset the maker receives.\\n      */\\n    function calculateMakingAmount(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        uint256 requestedTakingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes32 orderHash\\n    ) internal view returns(uint256) {\\n        bytes calldata data = extension.makingAmountData();\\n        if (data.length == 0) {\\n            // Linear proportion\\n            return AmountCalculatorLib.getMakingAmount(order.makingAmount, order.takingAmount, requestedTakingAmount);\\n        }\\n        return IAmountGetter(address(bytes20(data))).getMakingAmount(\\n            order,\\n            extension,\\n            orderHash,\\n            msg.sender,\\n            requestedTakingAmount,\\n            remainingMakingAmount,\\n            data[20:]\\n        );\\n    }\\n\\n    /**\\n      * @notice Calculates the taking amount based on the requested making amount.\\n      * @dev If getter is specified in the extension data, the getter is called to calculate the taking amount,\\n      * otherwise the taking amount is calculated linearly.\\n      * @param order The order.\\n      * @param extension The extension data associated with the order.\\n      * @param requestedMakingAmount The amount the maker wants to receive.\\n      * @param remainingMakingAmount The remaining amount of the asset left to be filled.\\n      * @param orderHash The hash of the order.\\n      * @return takingAmount The amount of the asset the taker takes.\\n      */\\n    function calculateTakingAmount(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        uint256 requestedMakingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes32 orderHash\\n    ) internal view returns(uint256) {\\n        bytes calldata data = extension.takingAmountData();\\n        if (data.length == 0) {\\n            // Linear proportion\\n            return AmountCalculatorLib.getTakingAmount(order.makingAmount, order.takingAmount, requestedMakingAmount);\\n        }\\n        return IAmountGetter(address(bytes20(data))).getTakingAmount(\\n            order,\\n            extension,\\n            orderHash,\\n            msg.sender,\\n            requestedMakingAmount,\\n            remainingMakingAmount,\\n            data[20:]\\n        );\\n    }\\n\\n    /**\\n      * @dev Validates the extension associated with an order.\\n      * @param order The order to validate against.\\n      * @param extension The extension associated with the order.\\n      * @return valid True if the extension is valid, false otherwise.\\n      * @return errorSelector The error selector if the extension is invalid, 0x00000000 otherwise.\\n      */\\n    function isValidExtension(IOrderMixin.Order calldata order, bytes calldata extension) internal pure returns(bool, bytes4) {\\n        if (order.makerTraits.hasExtension()) {\\n            if (extension.length == 0) return (false, MissingOrderExtension.selector);\\n            // Lowest 160 bits of the order salt must be equal to the lowest 160 bits of the extension hash\\n            if (uint256(keccak256(extension)) & type(uint160).max != order.salt & type(uint160).max) return (false, InvalidExtensionHash.selector);\\n        } else {\\n            if (extension.length > 0) return (false, UnexpectedOrderExtension.selector);\\n        }\\n        return (true, 0x00000000);\\n    }\\n}\\n\",\"keccak256\":\"0x2e2fcfc0887d0993e1bf2acb226410ab913cbffedfe55b151a0cabcc1d0f3205\",\"license\":\"MIT\"},\"contracts/helpers/OrderRegistrator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.30;\\n\\nimport { Address, AddressLib } from \\\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\\\";\\nimport { ECDSA } from \\\"@1inch/solidity-utils/contracts/libraries/ECDSA.sol\\\";\\nimport { IOrderMixin } from \\\"../interfaces/IOrderMixin.sol\\\";\\nimport { IOrderRegistrator } from \\\"../interfaces/IOrderRegistrator.sol\\\";\\nimport { OrderLib } from \\\"../OrderLib.sol\\\";\\n\\n/**\\n * @title OrderRegistrator\\n */\\ncontract OrderRegistrator is IOrderRegistrator {\\n    using AddressLib for Address;\\n    using OrderLib for IOrderMixin.Order;\\n\\n    IOrderMixin private immutable _LIMIT_ORDER_PROTOCOL;\\n\\n    constructor(IOrderMixin limitOrderProtocol) {\\n        _LIMIT_ORDER_PROTOCOL = limitOrderProtocol;\\n    }\\n\\n    /**\\n     * @notice See {IOrderRegistrator-registerOrder}.\\n     */\\n    function registerOrder(IOrderMixin.Order calldata order, bytes calldata extension, bytes calldata signature) external {\\n        // Validate order\\n        {\\n            (bool valid, bytes4 validationResult) = order.isValidExtension(extension);\\n            if (!valid) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly (\\\"memory-safe\\\") {\\n                    mstore(0, validationResult)\\n                    revert(0, 4)\\n                }\\n            }\\n        }\\n\\n        // Validate signature\\n        if(!ECDSA.recoverOrIsValidSignature(order.maker.get(), _LIMIT_ORDER_PROTOCOL.hashOrder(order), signature)) revert IOrderMixin.BadSignature();\\n\\n        emit OrderRegistered(order, extension, signature);\\n    }\\n}\\n\",\"keccak256\":\"0x9757bd8377510b7660593f6308d24feba16d651cb9b7ce4c6a49b04d1f4c3c5d\",\"license\":\"MIT\"},\"contracts/interfaces/IAmountGetter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOrderMixin.sol\\\";\\n\\n/**\\n * @title IAmountGetter\\n * @notice Interface for external logic to determine actual making and taking amounts for orders.\\n */\\ninterface IAmountGetter {\\n    /**\\n     * @notice View method that gets called to determine the actual making amount\\n     * @param order Order being processed\\n     * @param extension Order extension data\\n     * @param orderHash Hash of the order being processed\\n     * @param taker Taker address\\n     * @param takingAmount Actual taking amount\\n     * @param remainingMakingAmount Order remaining making amount\\n     * @param extraData Extra data\\n     * @return makingAmount Actual making amount that should be used for the order\\n     */\\n    function getMakingAmount(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice View method that gets called to determine the actual taking amount\\n     * @param order Order being processed\\n     * @param extension Order extension data\\n     * @param orderHash Hash of the order being processed\\n     * @param taker Taker address\\n     * @param makingAmount Actual taking amount\\n     * @param remainingMakingAmount Order remaining making amount\\n     * @param extraData Extra data\\n     * @return takingAmount Actual taking amount that should be used for the order\\n     */\\n    function getTakingAmount(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 makingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd2f5f477d812411a2eee26d645cd096b256221862fcf4a004128f7bdd43a6e08\",\"license\":\"MIT\"},\"contracts/interfaces/IOrderMixin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\\\";\\nimport \\\"../libraries/MakerTraitsLib.sol\\\";\\nimport \\\"../libraries/TakerTraitsLib.sol\\\";\\n\\n/**\\n * @title IOrderMixin\\n * @notice Interface for order processing logic in the 1inch Limit Order Protocol.\\n */\\ninterface IOrderMixin {\\n    struct Order {\\n        uint256 salt;\\n        Address maker;\\n        Address receiver;\\n        Address makerAsset;\\n        Address takerAsset;\\n        uint256 makingAmount;\\n        uint256 takingAmount;\\n        MakerTraits makerTraits;\\n    }\\n\\n    error InvalidatedOrder();\\n    error TakingAmountExceeded();\\n    error PrivateOrder();\\n    error BadSignature();\\n    error OrderExpired();\\n    error WrongSeriesNonce();\\n    error SwapWithZeroAmount();\\n    error PartialFillNotAllowed();\\n    error OrderIsNotSuitableForMassInvalidation();\\n    error EpochManagerAndBitInvalidatorsAreIncompatible();\\n    error ReentrancyDetected();\\n    error PredicateIsNotTrue();\\n    error TakingAmountTooHigh();\\n    error MakingAmountTooLow();\\n    error TransferFromMakerToTakerFailed();\\n    error TransferFromTakerToMakerFailed();\\n    error MismatchArraysLengths();\\n    error InvalidPermit2Transfer();\\n    error SimulationResults(bool success, bytes res);\\n\\n    /**\\n     * @notice Emitted when order gets filled\\n     * @param orderHash Hash of the order\\n     * @param remainingAmount Amount of the maker asset that remains to be filled\\n     */\\n    event OrderFilled(\\n        bytes32 orderHash,\\n        uint256 remainingAmount\\n    );\\n\\n    /**\\n     * @notice Emitted when order without `useBitInvalidator` gets cancelled\\n     * @param orderHash Hash of the order\\n     */\\n    event OrderCancelled(\\n        bytes32 orderHash\\n    );\\n\\n    /**\\n     * @notice Emitted when order with `useBitInvalidator` gets cancelled\\n     * @param maker Maker address\\n     * @param slotIndex Slot index that was updated\\n     * @param slotValue New slot value\\n     */\\n    event BitInvalidatorUpdated(\\n        address indexed maker,\\n        uint256 slotIndex,\\n        uint256 slotValue\\n    );\\n\\n    /**\\n     * @notice Delegates execution to custom implementation. Could be used to validate if `transferFrom` works properly\\n     * @dev The function always reverts and returns the simulation results in revert data.\\n     * @param target Addresses that will be delegated\\n     * @param data Data that will be passed to delegatee\\n     */\\n    function simulate(address target, bytes calldata data) external;\\n\\n    /**\\n     * @notice Cancels order's quote\\n     * @param makerTraits Order makerTraits\\n     * @param orderHash Hash of the order to cancel\\n     */\\n    function cancelOrder(MakerTraits makerTraits, bytes32 orderHash) external;\\n\\n    /**\\n     * @notice Cancels orders' quotes\\n     * @param makerTraits Orders makerTraits\\n     * @param orderHashes Hashes of the orders to cancel\\n     */\\n    function cancelOrders(MakerTraits[] calldata makerTraits, bytes32[] calldata orderHashes) external;\\n\\n    /**\\n     * @notice Cancels all quotes of the maker (works for bit-invalidating orders only)\\n     * @param makerTraits Order makerTraits\\n     * @param additionalMask Additional bitmask to invalidate orders\\n     */\\n    function bitsInvalidateForOrder(MakerTraits makerTraits, uint256 additionalMask) external;\\n\\n    /**\\n     * @notice Fills order's quote, fully or partially (whichever is possible).\\n     * @param order Order quote to fill\\n     * @param r R component of signature\\n     * @param vs VS component of signature\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     */\\n    function fillOrder(\\n        Order calldata order,\\n        bytes32 r,\\n        bytes32 vs,\\n        uint256 amount,\\n        TakerTraits takerTraits\\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillOrder` but allows to specify arguments that are used by the taker.\\n     * @param order Order quote to fill\\n     * @param r R component of signature\\n     * @param vs VS component of signature\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     */\\n    function fillOrderArgs(\\n        IOrderMixin.Order calldata order,\\n        bytes32 r,\\n        bytes32 vs,\\n        uint256 amount,\\n        TakerTraits takerTraits,\\n        bytes calldata args\\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillOrder` but uses contract-based signatures.\\n     * @param order Order quote to fill\\n     * @param signature Signature to confirm quote ownership\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     * @dev See tests for examples\\n     */\\n    function fillContractOrder(\\n        Order calldata order,\\n        bytes calldata signature,\\n        uint256 amount,\\n        TakerTraits takerTraits\\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillContractOrder` but allows to specify arguments that are used by the taker.\\n     * @param order Order quote to fill\\n     * @param signature Signature to confirm quote ownership\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     * @dev See tests for examples\\n     */\\n    function fillContractOrderArgs(\\n        Order calldata order,\\n        bytes calldata signature,\\n        uint256 amount,\\n        TakerTraits takerTraits,\\n        bytes calldata args\\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param maker Maker address\\n     * @param slot Slot number to return bitmask for\\n     * @return result Each bit represents whether corresponding was already invalidated\\n     */\\n    function bitInvalidatorForOrder(address maker, uint256 slot) external view returns(uint256 result);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param orderHash Hash of the order\\n     * @return remaining Remaining amount of the order\\n     */\\n    function remainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remaining);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param orderHash Hash of the order\\n     * @return remainingRaw Inverse of the remaining amount of the order if order was filled at least once, otherwise 0\\n     */\\n    function rawRemainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remainingRaw);\\n\\n    /**\\n     * @notice Returns order hash, hashed with limit order protocol contract EIP712\\n     * @param order Order\\n     * @return orderHash Hash of the order\\n     */\\n    function hashOrder(IOrderMixin.Order calldata order) external view returns(bytes32 orderHash);\\n}\\n\",\"keccak256\":\"0x39cfb84ae74a276eae63d7b3be898104045f98163405190227ddae3e85f6dd11\",\"license\":\"MIT\"},\"contracts/interfaces/IOrderRegistrator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.30;\\n\\nimport { IOrderMixin } from \\\"./IOrderMixin.sol\\\";\\n\\n/**\\n * @title IOrderRegistrator\\n * @dev The interface defines the structure of the order registrator contract.\\n * The registrator is responsible for registering orders and emitting an event when an order is registered.\\n */\\ninterface IOrderRegistrator {\\n    /**\\n     * @notice Emitted when an order is registered.\\n     * @param order The order that was registered.\\n     * @param extension The extension data associated with the order.\\n     * @param signature The signature of the order.\\n     */\\n    event OrderRegistered(IOrderMixin.Order order, bytes extension, bytes signature);\\n\\n    /**\\n     * @notice Registers an order.\\n     * @param order The order to be registered.\\n     * @param extension The extension data associated with the order.\\n     * @param signature The signature of the order.\\n     */\\n    function registerOrder(IOrderMixin.Order calldata order, bytes calldata extension, bytes calldata signature) external;\\n}\\n\",\"keccak256\":\"0x755979dc6c8a6a8961af0bb7bacacc157080de3e5fb4e96061034701756bf048\",\"license\":\"MIT\"},\"contracts/libraries/AmountCalculatorLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.30;\\n\\n/// @title The helper library to calculate linearly taker amount from maker amount and vice versa.\\nlibrary AmountCalculatorLib {\\n    /// @notice Calculates maker amount\\n    /// @return Result Floored maker amount\\n    function getMakingAmount(uint256 orderMakerAmount, uint256 orderTakerAmount, uint256 swapTakerAmount) internal pure returns(uint256) {\\n        if ((swapTakerAmount | orderMakerAmount) >> 128 == 0) {\\n            unchecked {\\n                return (swapTakerAmount * orderMakerAmount) / orderTakerAmount;\\n            }\\n        }\\n        return swapTakerAmount * orderMakerAmount / orderTakerAmount;\\n    }\\n\\n    /// @notice Calculates taker amount\\n    /// @return Result Ceiled taker amount\\n    function getTakingAmount(uint256 orderMakerAmount, uint256 orderTakerAmount, uint256 swapMakerAmount) internal pure returns(uint256) {\\n        if ((swapMakerAmount | orderTakerAmount) >> 128 == 0) {\\n            unchecked {\\n                return (swapMakerAmount * orderTakerAmount + orderMakerAmount - 1) / orderMakerAmount;\\n            }\\n        }\\n        return (swapMakerAmount * orderTakerAmount + orderMakerAmount - 1) / orderMakerAmount;\\n    }\\n}\\n\",\"keccak256\":\"0x344a22ae2ec5e0b59db671d59c1b073f11e914d3ef3fe7b4b86b64e75ee69893\",\"license\":\"MIT\"},\"contracts/libraries/ExtensionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IOrderMixin.sol\\\";\\nimport \\\"./OffsetsLib.sol\\\";\\n\\n/**\\n * @title ExtensionLib\\n * @notice Library for retrieving extensions information for the IOrderMixin Interface.\\n */\\nlibrary ExtensionLib {\\n    using AddressLib for Address;\\n    using OffsetsLib for Offsets;\\n\\n    enum DynamicField {\\n        MakerAssetSuffix,\\n        TakerAssetSuffix,\\n        MakingAmountData,\\n        TakingAmountData,\\n        Predicate,\\n        MakerPermit,\\n        PreInteractionData,\\n        PostInteractionData,\\n        CustomData\\n    }\\n\\n    /**\\n     * @notice Returns the MakerAssetSuffix from the provided extension calldata.\\n     * @param extension The calldata from which the MakerAssetSuffix is to be retrieved.\\n     * @return calldata Bytes representing the MakerAssetSuffix.\\n     */\\n    function makerAssetSuffix(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.MakerAssetSuffix);\\n    }\\n\\n    /**\\n     * @notice Returns the TakerAssetSuffix from the provided extension calldata.\\n     * @param extension The calldata from which the TakerAssetSuffix is to be retrieved.\\n     * @return calldata Bytes representing the TakerAssetSuffix.\\n     */\\n    function takerAssetSuffix(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.TakerAssetSuffix);\\n    }\\n\\n    /**\\n     * @notice Returns the MakingAmountData from the provided extension calldata.\\n     * @param extension The calldata from which the MakingAmountData is to be retrieved.\\n     * @return calldata Bytes representing the MakingAmountData.\\n     */\\n    function makingAmountData(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.MakingAmountData);\\n    }\\n\\n    /**\\n     * @notice Returns the TakingAmountData from the provided extension calldata.\\n     * @param extension The calldata from which the TakingAmountData is to be retrieved.\\n     * @return calldata Bytes representing the TakingAmountData.\\n     */\\n    function takingAmountData(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.TakingAmountData);\\n    }\\n\\n    /**\\n     * @notice Returns the order's predicate from the provided extension calldata.\\n     * @param extension The calldata from which the predicate is to be retrieved.\\n     * @return calldata Bytes representing the predicate.\\n     */\\n    function predicate(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.Predicate);\\n    }\\n\\n    /**\\n     * @notice Returns the maker's permit from the provided extension calldata.\\n     * @param extension The calldata from which the maker's permit is to be retrieved.\\n     * @return calldata Bytes representing the maker's permit.\\n     */\\n    function makerPermit(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.MakerPermit);\\n    }\\n\\n\\n    /**\\n     * @notice Returns the pre-interaction from the provided extension calldata.\\n     * @param extension The calldata from which the pre-interaction is to be retrieved.\\n     * @return calldata Bytes representing the pre-interaction.\\n     */\\n    function preInteractionTargetAndData(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.PreInteractionData);\\n    }\\n\\n    /**\\n     * @notice Returns the post-interaction from the provided extension calldata.\\n     * @param extension The calldata from which the post-interaction is to be retrieved.\\n     * @return calldata Bytes representing the post-interaction.\\n     */\\n    function postInteractionTargetAndData(bytes calldata extension) internal pure returns(bytes calldata) {\\n        return _get(extension, DynamicField.PostInteractionData);\\n    }\\n\\n    /**\\n     * @notice Returns extra suffix data from the provided extension calldata.\\n     * @param extension The calldata from which the extra suffix data is to be retrieved.\\n     * @return calldata Bytes representing the extra suffix data.\\n     */\\n    function customData(bytes calldata extension) internal pure returns(bytes calldata) {\\n        if (extension.length < 0x20) return msg.data[:0];\\n        uint256 offsets = uint256(bytes32(extension));\\n        unchecked {\\n            return extension[0x20 + (offsets >> 224):];\\n        }\\n    }\\n\\n    /**\\n     * @notice Retrieves a specific field from the provided extension calldata.\\n     * @dev The first 32 bytes of an extension calldata contain offsets to the end of each field within the calldata.\\n     * @param extension The calldata from which the field is to be retrieved.\\n     * @param field The specific dynamic field to retrieve from the extension.\\n     * @return calldata Bytes representing the requested field.\\n     */\\n    function _get(bytes calldata extension, DynamicField field) private pure returns(bytes calldata) {\\n        if (extension.length < 0x20) return msg.data[:0];\\n\\n        Offsets offsets;\\n        bytes calldata concat;\\n        assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n            offsets := calldataload(extension.offset)\\n            concat.offset := add(extension.offset, 0x20)\\n            concat.length := sub(extension.length, 0x20)\\n        }\\n\\n        return offsets.get(concat, uint256(field));\\n    }\\n}\\n\",\"keccak256\":\"0x0e1ef5b959f77126f61c10e11fcd6043832baf9260cfb2bcf9bff8e446bae65d\",\"license\":\"MIT\"},\"contracts/libraries/MakerTraitsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype MakerTraits is uint256;\\n\\n/**\\n * @title MakerTraitsLib\\n * @notice A library to manage and check MakerTraits, which are used to encode the maker's preferences for an order in a single uint256.\\n * @dev\\n * The MakerTraits type is a uint256 and different parts of the number are used to encode different traits.\\n * High bits are used for flags\\n * 255 bit `NO_PARTIAL_FILLS_FLAG`          - if set, the order does not allow partial fills\\n * 254 bit `ALLOW_MULTIPLE_FILLS_FLAG`      - if set, the order permits multiple fills\\n * 253 bit                                  - unused\\n * 252 bit `PRE_INTERACTION_CALL_FLAG`      - if set, the order requires pre-interaction call\\n * 251 bit `POST_INTERACTION_CALL_FLAG`     - if set, the order requires post-interaction call\\n * 250 bit `NEED_CHECK_EPOCH_MANAGER_FLAG`  - if set, the order requires to check the epoch manager\\n * 249 bit `HAS_EXTENSION_FLAG`             - if set, the order has extension(s)\\n * 248 bit `USE_PERMIT2_FLAG`               - if set, the order uses permit2\\n * 247 bit `UNWRAP_WETH_FLAG`               - if set, the order requires to unwrap WETH\\n\\n * Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\\n * uint80 last 10 bytes of allowed sender address (0 if any)\\n * uint40 expiration timestamp (0 if none)\\n * uint40 nonce or epoch\\n * uint40 series\\n */\\nlibrary MakerTraitsLib {\\n    // Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\\n    uint256 private constant _ALLOWED_SENDER_MASK = type(uint80).max;\\n    uint256 private constant _EXPIRATION_OFFSET = 80;\\n    uint256 private constant _EXPIRATION_MASK = type(uint40).max;\\n    uint256 private constant _NONCE_OR_EPOCH_OFFSET = 120;\\n    uint256 private constant _NONCE_OR_EPOCH_MASK = type(uint40).max;\\n    uint256 private constant _SERIES_OFFSET = 160;\\n    uint256 private constant _SERIES_MASK = type(uint40).max;\\n\\n    uint256 private constant _NO_PARTIAL_FILLS_FLAG = 1 << 255;\\n    uint256 private constant _ALLOW_MULTIPLE_FILLS_FLAG = 1 << 254;\\n    uint256 private constant _PRE_INTERACTION_CALL_FLAG = 1 << 252;\\n    uint256 private constant _POST_INTERACTION_CALL_FLAG = 1 << 251;\\n    uint256 private constant _NEED_CHECK_EPOCH_MANAGER_FLAG = 1 << 250;\\n    uint256 private constant _HAS_EXTENSION_FLAG = 1 << 249;\\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 248;\\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 247;\\n\\n    /**\\n     * @notice Checks if the order has the extension flag set.\\n     * @dev If the `HAS_EXTENSION_FLAG` is set in the makerTraits, then the protocol expects that the order has extension(s).\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the flag is set.\\n     */\\n    function hasExtension(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _HAS_EXTENSION_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker allows a specific taker to fill the order.\\n     * @param makerTraits The traits of the maker.\\n     * @param sender The address of the taker to be checked.\\n     * @return result A boolean indicating whether the taker is allowed.\\n     */\\n    function isAllowedSender(MakerTraits makerTraits, address sender) internal pure returns (bool) {\\n        uint160 allowedSender = uint160(MakerTraits.unwrap(makerTraits) & _ALLOWED_SENDER_MASK);\\n        return allowedSender == 0 || allowedSender == uint160(sender) & _ALLOWED_SENDER_MASK;\\n    }\\n\\n    /**\\n     * @notice Returns the expiration time of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The expiration timestamp of the order.\\n     */\\n    function getExpirationTime(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _EXPIRATION_OFFSET) & _EXPIRATION_MASK;\\n    }\\n\\n    /**\\n     * @notice Checks if the order has expired.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the order has expired.\\n     */\\n    function isExpired(MakerTraits makerTraits) internal view returns (bool) {\\n        uint256 expiration = getExpirationTime(makerTraits);\\n        return expiration != 0 && expiration < block.timestamp;  // solhint-disable-line not-rely-on-time\\n    }\\n\\n    /**\\n     * @notice Returns the nonce or epoch of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The nonce or epoch of the order.\\n     */\\n    function nonceOrEpoch(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _NONCE_OR_EPOCH_OFFSET) & _NONCE_OR_EPOCH_MASK;\\n    }\\n\\n    /**\\n     * @notice Returns the series of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The series of the order.\\n     */\\n    function series(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _SERIES_OFFSET) & _SERIES_MASK;\\n    }\\n\\n    /**\\n      * @notice Determines if the order allows partial fills.\\n      * @dev If the _NO_PARTIAL_FILLS_FLAG is not set in the makerTraits, then the order allows partial fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the maker allows partial fills.\\n      */\\n    function allowPartialFills(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _NO_PARTIAL_FILLS_FLAG) == 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs pre-interaction call.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs a pre-interaction call.\\n     */\\n    function needPreInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _PRE_INTERACTION_CALL_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs post-interaction call.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs a post-interaction call.\\n     */\\n    function needPostInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _POST_INTERACTION_CALL_FLAG) != 0;\\n    }\\n\\n    /**\\n      * @notice Determines if the order allows multiple fills.\\n      * @dev If the _ALLOW_MULTIPLE_FILLS_FLAG is set in the makerTraits, then the maker allows multiple fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the maker allows multiple fills.\\n      */\\n    function allowMultipleFills(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _ALLOW_MULTIPLE_FILLS_FLAG) != 0;\\n    }\\n\\n    /**\\n      * @notice Determines if an order should use the bit invalidator or remaining amount validator.\\n      * @dev The bit invalidator can be used if the order does not allow partial or multiple fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the bit invalidator should be used.\\n      * True if the order requires the use of the bit invalidator.\\n      */\\n    function useBitInvalidator(MakerTraits makerTraits) internal pure returns (bool) {\\n        return !allowPartialFills(makerTraits) || !allowMultipleFills(makerTraits);\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs to check the epoch.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs to check the epoch manager.\\n     */\\n    function needCheckEpochManager(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _NEED_CHECK_EPOCH_MANAGER_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker uses permit2.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker uses permit2.\\n     */\\n    function usePermit2(MakerTraits makerTraits) internal pure returns (bool) {\\n        return MakerTraits.unwrap(makerTraits) & _USE_PERMIT2_FLAG != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs to unwraps WETH.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs to unwrap WETH.\\n     */\\n    function unwrapWeth(MakerTraits makerTraits) internal pure returns (bool) {\\n        return MakerTraits.unwrap(makerTraits) & _UNWRAP_WETH_FLAG != 0;\\n    }\\n}\\n\",\"keccak256\":\"0x9506febc99293a286356a03cb150ad82ccb88be1b4c908183e1273b41fcb902c\",\"license\":\"MIT\"},\"contracts/libraries/OffsetsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype Offsets is uint256;\\n\\n/// @title OffsetsLib\\n/// @dev A library for retrieving values by offsets from a concatenated calldata.\\nlibrary OffsetsLib {\\n\\n    /// @dev Error to be thrown when the offset is out of bounds.\\n    error OffsetOutOfBounds();\\n\\n    /**\\n     * @notice Retrieves the field value calldata corresponding to the provided field index from the concatenated calldata.\\n     * @dev \\n     * The function performs the following steps:\\n     * 1. Retrieve the start and end of the segment corresponding to the provided index from the offsets array.\\n     * 2. Get the value from segment using offset and length calculated based on the start and end of the segment.\\n     * 3. Throw `OffsetOutOfBounds` error if the length of the segment is greater than the length of the concatenated data.\\n     * @param offsets The offsets encoding the start and end of each segment within the concatenated calldata.\\n     * @param concat The concatenated calldata.\\n     * @param index The index of the segment to retrieve. The field index 0 corresponds to the lowest bytes of the offsets array.\\n     * @return result The calldata from a segment of the concatenated calldata corresponding to the provided index.\\n     */\\n    function get(Offsets offsets, bytes calldata concat, uint256 index) internal pure returns(bytes calldata result) {\\n        bytes4 exception = OffsetOutOfBounds.selector;\\n        assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n            let bitShift := shl(5, index)                                   // bitShift = index * 32\\n            let begin := and(0xffffffff, shr(bitShift, shl(32, offsets)))   // begin = offsets[ bitShift : bitShift + 32 ]\\n            let end := and(0xffffffff, shr(bitShift, offsets))              // end   = offsets[ bitShift + 32 : bitShift + 64 ]\\n            result.offset := add(concat.offset, begin)\\n            result.length := sub(end, begin)\\n            if gt(end, concat.length) {\\n                mstore(0, exception)\\n                revert(0, 4)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb28030050b4c7b78e0ab596a98d3f437c1fce386b8de0a56a557209e0754636b\",\"license\":\"MIT\"},\"contracts/libraries/TakerTraitsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype TakerTraits is uint256;\\n\\n/**\\n * @title TakerTraitsLib\\n * @notice This library to manage and check TakerTraits, which are used to encode the taker's preferences for an order in a single uint256.\\n * @dev The TakerTraits are structured as follows:\\n * High bits are used for flags\\n * 255 bit `_MAKER_AMOUNT_FLAG`           - If set, the taking amount is calculated based on making amount, otherwise making amount is calculated based on taking amount.\\n * 254 bit `_UNWRAP_WETH_FLAG`            - If set, the WETH will be unwrapped into ETH before sending to taker.\\n * 253 bit `_SKIP_ORDER_PERMIT_FLAG`      - If set, the order skips maker's permit execution.\\n * 252 bit `_USE_PERMIT2_FLAG`            - If set, the order uses the permit2 function for authorization.\\n * 251 bit `_ARGS_HAS_TARGET`             - If set, then first 20 bytes of args are treated as target address for maker\\u2019s funds transfer.\\n * 224-247 bits `ARGS_EXTENSION_LENGTH`   - The length of the extension calldata in the args.\\n * 200-223 bits `ARGS_INTERACTION_LENGTH` - The length of the interaction calldata in the args.\\n * 0-184 bits                             - The threshold amount (the maximum amount a taker agrees to give in exchange for a making amount).\\n */\\nlibrary TakerTraitsLib {\\n    uint256 private constant _MAKER_AMOUNT_FLAG = 1 << 255;\\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 254;\\n    uint256 private constant _SKIP_ORDER_PERMIT_FLAG = 1 << 253;\\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 252;\\n    uint256 private constant _ARGS_HAS_TARGET = 1 << 251;\\n\\n    uint256 private constant _ARGS_EXTENSION_LENGTH_OFFSET = 224;\\n    uint256 private constant _ARGS_EXTENSION_LENGTH_MASK = 0xffffff;\\n    uint256 private constant _ARGS_INTERACTION_LENGTH_OFFSET = 200;\\n    uint256 private constant _ARGS_INTERACTION_LENGTH_MASK = 0xffffff;\\n\\n    uint256 private constant _AMOUNT_MASK = 0x000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    /**\\n     * @notice Checks if the args should contain target address.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the args should contain target address.\\n     */\\n    function argsHasTarget(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _ARGS_HAS_TARGET) != 0;\\n    }\\n\\n    /**\\n     * @notice Retrieves the length of the extension calldata from the takerTraits.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The length of the extension calldata encoded in the takerTraits.\\n     */\\n    function argsExtensionLength(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_EXTENSION_LENGTH_OFFSET) & _ARGS_EXTENSION_LENGTH_MASK;\\n    }\\n\\n    /**\\n     * @notice Retrieves the length of the interaction calldata from the takerTraits.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The length of the interaction calldata encoded in the takerTraits.\\n     */\\n    function argsInteractionLength(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_INTERACTION_LENGTH_OFFSET) & _ARGS_INTERACTION_LENGTH_MASK;\\n    }\\n\\n    /**\\n     * @notice Checks if the taking amount should be calculated based on making amount.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the taking amount should be calculated based on making amount.\\n     */\\n    function isMakingAmount(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _MAKER_AMOUNT_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order should unwrap WETH and send ETH to taker.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order should unwrap WETH.\\n     */\\n    function unwrapWeth(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _UNWRAP_WETH_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order should skip maker's permit execution.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order don't apply permit.\\n     */\\n    function skipMakerPermit(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _SKIP_ORDER_PERMIT_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order uses the permit2 instead of permit.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order uses the permit2.\\n     */\\n    function usePermit2(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _USE_PERMIT2_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Retrieves the threshold amount from the takerTraits.\\n     * The maximum amount a taker agrees to give in exchange for a making amount.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The threshold amount encoded in the takerTraits.\\n     */\\n    function threshold(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return TakerTraits.unwrap(takerTraits) & _AMOUNT_MASK;\\n    }\\n}\\n\",\"keccak256\":\"0x144f154a46e8daa0fec5b8215f1d8d3b694cb939236aa7bf89976b27965c2837\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a034606657601f61075338819003918201601f19168301916001600160401b03831184841017606a57808492602094604052833981010312606657516001600160a01b03811681036066576080526040516106d4908161007f82396080518161013e0152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040526004361015610011575f80fd5b5f3560e01c63dfcb3e3414610024575f80fd5b3461028a577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601610140811261028a576101001361028a576101043567ffffffffffffffff811161028a5761007e9036906004016102a8565b906101243567ffffffffffffffff811161028a576100a09036906004016102a8565b6100ad8484959395610382565b90156102a157506040517f802b2ef1000000000000000000000000000000000000000000000000000000008152610120600482016004358152602435602082015260443560408201526064356060820152608435608082015260a43560a082015260c43560c082015260e060e435910152565b6020816101048173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa8015610296578583915f9061025a575b610193935073ffffffffffffffffffffffffffffffffffffffff602435166104ce565b15610232577f1e8610b3a2275f01a103e27257e911d890537b0c70578537ea077ec0a27b5bc99361022d9161021e60405195869561020a876004358152602435602082015260443560408201526064356060820152608435608082015260a43560a082015260c43560c082015260e060e435910152565b610140610100880152610140870191610344565b91848303610120860152610344565b0390a1005b7f5cd5d233000000000000000000000000000000000000000000000000000000005f5260045ffd5b5050506020813d60201161028e575b81610276602093836102d6565b8101031261028a5781856101939251610170565b5f80fd5b3d9150610269565b6040513d5f823e3d90fd5b5f5260045ffd5b9181601f8401121561028a5782359167ffffffffffffffff831161028a576020838186019501011161028a57565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761031757604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b9060e4357f020000000000000000000000000000000000000000000000000000000000000016156104a15780156104795767ffffffffffffffff8111610317576040516103f760207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f85011601826102d6565b8181526020810191368185011161028a576020815f9273ffffffffffffffffffffffffffffffffffffffff968637830101525190201673ffffffffffffffffffffffffffffffffffffffff6004351603610453575b6001905f90565b5f907fdc11ee6b0000000000000000000000000000000000000000000000000000000090565b50505f907fb2d25e490000000000000000000000000000000000000000000000000000000090565b90501561044c575f907f74896a7b0000000000000000000000000000000000000000000000000000000090565b9290919273ffffffffffffffffffffffffffffffffffffffff81168015610695576040831490811561068a575b8161058f575b50610586576020925f92808496604051937f1626ba7e0000000000000000000000000000000000000000000000000000000085526004850152604060248501528160448501526064840137606401915afa6105595790565b5060203d145f517f1626ba7e00000000000000000000000000000000000000000000000000000000141690565b50505050600190565b90505f604051848060411461066f5760401461062857505f90815b6105ce575b73ffffffffffffffffffffffffffffffffffffffff915016145f610501565b7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1606083015110156105af57505f608082876020945282805260015afa5073ffffffffffffffffffffffffffffffffffffffff5f516105af565b90817f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60208901358060ff1c601b01602084015260208a60408501371660608201526105aa565b509060408701355f1a602083015281604088818301376105aa565b6041841491506104fb565b50505050505f9056fea2646970667358221220ba2b21863143164df6211de9d15b133dbdc590aaceb081e7cb6a711f7deff19f64736f6c634300081e0033",
  "deployedBytecode": "0x60806040526004361015610011575f80fd5b5f3560e01c63dfcb3e3414610024575f80fd5b3461028a577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601610140811261028a576101001361028a576101043567ffffffffffffffff811161028a5761007e9036906004016102a8565b906101243567ffffffffffffffff811161028a576100a09036906004016102a8565b6100ad8484959395610382565b90156102a157506040517f802b2ef1000000000000000000000000000000000000000000000000000000008152610120600482016004358152602435602082015260443560408201526064356060820152608435608082015260a43560a082015260c43560c082015260e060e435910152565b6020816101048173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa8015610296578583915f9061025a575b610193935073ffffffffffffffffffffffffffffffffffffffff602435166104ce565b15610232577f1e8610b3a2275f01a103e27257e911d890537b0c70578537ea077ec0a27b5bc99361022d9161021e60405195869561020a876004358152602435602082015260443560408201526064356060820152608435608082015260a43560a082015260c43560c082015260e060e435910152565b610140610100880152610140870191610344565b91848303610120860152610344565b0390a1005b7f5cd5d233000000000000000000000000000000000000000000000000000000005f5260045ffd5b5050506020813d60201161028e575b81610276602093836102d6565b8101031261028a5781856101939251610170565b5f80fd5b3d9150610269565b6040513d5f823e3d90fd5b5f5260045ffd5b9181601f8401121561028a5782359167ffffffffffffffff831161028a576020838186019501011161028a57565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761031757604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b9060e4357f020000000000000000000000000000000000000000000000000000000000000016156104a15780156104795767ffffffffffffffff8111610317576040516103f760207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f85011601826102d6565b8181526020810191368185011161028a576020815f9273ffffffffffffffffffffffffffffffffffffffff968637830101525190201673ffffffffffffffffffffffffffffffffffffffff6004351603610453575b6001905f90565b5f907fdc11ee6b0000000000000000000000000000000000000000000000000000000090565b50505f907fb2d25e490000000000000000000000000000000000000000000000000000000090565b90501561044c575f907f74896a7b0000000000000000000000000000000000000000000000000000000090565b9290919273ffffffffffffffffffffffffffffffffffffffff81168015610695576040831490811561068a575b8161058f575b50610586576020925f92808496604051937f1626ba7e0000000000000000000000000000000000000000000000000000000085526004850152604060248501528160448501526064840137606401915afa6105595790565b5060203d145f517f1626ba7e00000000000000000000000000000000000000000000000000000000141690565b50505050600190565b90505f604051848060411461066f5760401461062857505f90815b6105ce575b73ffffffffffffffffffffffffffffffffffffffff915016145f610501565b7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1606083015110156105af57505f608082876020945282805260015afa5073ffffffffffffffffffffffffffffffffffffffff5f516105af565b90817f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60208901358060ff1c601b01602084015260208a60408501371660608201526105aa565b509060408701355f1a602083015281604088818301376105aa565b6041841491506104fb565b50505050505f9056fea2646970667358221220ba2b21863143164df6211de9d15b133dbdc590aaceb081e7cb6a711f7deff19f64736f6c634300081e0033",
  "devdoc": {
    "events": {
      "OrderRegistered((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes)": {
        "params": {
          "extension": "The extension data associated with the order.",
          "order": "The order that was registered.",
          "signature": "The signature of the order."
        }
      }
    },
    "kind": "dev",
    "methods": {},
    "title": "OrderRegistrator",
    "version": 1
  },
  "userdoc": {
    "events": {
      "OrderRegistered((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes)": {
        "notice": "Emitted when an order is registered."
      }
    },
    "kind": "user",
    "methods": {
      "registerOrder((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes)": {
        "notice": "See {IOrderRegistrator-registerOrder}."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}